{"version":3,"sources":["../dist-esnext/Board.js"],"names":["Position","Positions","defaultBoardSize","x","y","hasPosition","board","position","length","mapBoard","func","map","col","getColorStartEndRow","boardEndRow","isBlack","startRow","endRow","getBoardConf","boardSize","size","white","black","defaultBoardConf","_getInitialBoard","memoize","boardConf","blackPieces","whitePieces","push","getInitialBoard","defaultInitialBoard","isBackGroundBlack","getToSearchOrder","getY0Start7End","getY7Start0End","getPosition","e","Error","setPosition","setPieceOnBoard","setPiece","removePieceOnBoard","removePiece","clean","iCanGoHere","lastMove","lastMoveJump","getPositionsWhereCanIGo","from","allNearPositions","getNearPositions","undefined","positions","orderedPositions","i","nearPosition","hasNoPiece","jumpPosition","getJumpPosition","jumps","whereCanIJump","onlyEmpty","add","plusX","plusY","newPosition","toJumpPosition","hasPiece","jumpfrom","nearFilledPositions","forEach","nearFilledPosition","notContains","lastPosition","jumpingBlackPiece","setWhereCanIGo","blackPiece","contains","printUnicode","txt","hasWhitePiece","hasBlackPiece","getBoardAfterMove","move","to"],"mappings":"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","file":"Board.js","sourcesContent":["import R from 'ramda';\nimport * as Position from './Position';\nimport * as Positions from './Positions';\nimport log from 'ptz-log';\n/**\n * Default 8x8 board size\n */\nconst defaultBoardSize = {\n    x: 8,\n    y: 8\n};\n/**\n * Check if position exists on board\n */\nfunction hasPosition(board, position) {\n    if (!position)\n        return false;\n    if (position.x < 0 || board.length <= position.x)\n        return false;\n    if (position.y < 0 || board[position.x].length <= position.y)\n        return false;\n    return true;\n}\n/**\n * Map some function in all board positions and return a new board\n */\nfunction mapBoard(board, func) {\n    return board.map(col => col.map(position => func(position)));\n}\nfunction getColorStartEndRow(boardEndRow, isBlack) {\n    return {\n        startRow: isBlack ? 0 : boardEndRow,\n        endRow: isBlack ? boardEndRow : 0\n    };\n}\nfunction getBoardConf(boardSize) {\n    const endRow = boardSize.y - 1;\n    return {\n        size: boardSize,\n        endRow,\n        white: getColorStartEndRow(endRow, false),\n        black: getColorStartEndRow(endRow, true)\n    };\n}\nconst defaultBoardConf = getBoardConf(defaultBoardSize);\n// tslint:disable-next-line:variable-name\nconst _getInitialBoard = R.memoize((boardConf) => {\n    log('_getInitialBoard for', boardConf);\n    const board = [], blackPieces = [], whitePieces = [];\n    for (let x = 0; x < boardConf.size.x; x++) {\n        for (let y = 0; y < boardConf.size.y; y++) {\n            if (!board[x])\n                board[x] = [];\n            const position = { x, y };\n            if (y === 0) {\n                position.isBlack = true;\n                blackPieces.push({ position });\n            }\n            if (y === boardConf.endRow) {\n                position.isBlack = false;\n                whitePieces.push({ position });\n            }\n            board[x][y] = position;\n        }\n    }\n    return {\n        board,\n        blackPieces,\n        whitePieces\n    };\n});\nfunction getInitialBoard(boardConf) {\n    return _getInitialBoard(boardConf);\n}\n/**\n * [ATENTION] USE IT ONLY FOR TESTS!\n * Code for any board size =D\n *\n * Default 8x8 board in start position\n */\nconst defaultInitialBoard = getInitialBoard(defaultBoardConf).board;\nfunction isBackGroundBlack(x, y) {\n    if (x % 2 === 0) {\n        if (y % 2 === 0)\n            return true;\n        else\n            return false;\n    }\n    else {\n        if (y % 2 === 0)\n            return false;\n        else\n            return true;\n    }\n}\n/**\n * Returns the index to store the position in orderedPositions\n *\n * The order to search is 0, 7, 1, 6, 2, 5, 3, 1\n *\n * The goal is to fill the corners first\n */\nfunction getToSearchOrder(x) {\n    switch (x) {\n        case 0:\n            return 0;\n        case 1:\n            return 2;\n        case 2:\n            return 4;\n        case 3:\n            return 6;\n        case 4:\n            return 7;\n        case 5:\n            return 5;\n        case 6:\n            return 3;\n        case 7:\n            return 1;\n        default:\n            return null;\n    }\n}\n/**\n * Get Y starting from 0 and ending on 7 for black and white pieces\n */\nfunction getY0Start7End(y, isBlack) {\n    if (isBlack)\n        return y;\n    switch (y) {\n        case 0:\n            return 7;\n        case 1:\n            return 6;\n        case 2:\n            return 5;\n        case 3:\n            return 4;\n        case 4:\n            return 3;\n        case 5:\n            return 2;\n        case 6:\n            return 1;\n        case 7:\n            return 0;\n        default:\n            return null;\n    }\n}\n/**\n * Get Y starting from 7 and ending on 0 for black and white pieces\n */\nfunction getY7Start0End(y, isBlack) {\n    if (!isBlack)\n        return y;\n    switch (y) {\n        case 0:\n            return 7;\n        case 1:\n            return 6;\n        case 2:\n            return 5;\n        case 3:\n            return 4;\n        case 4:\n            return 3;\n        case 5:\n            return 2;\n        case 6:\n            return 1;\n        case 7:\n            return 0;\n        default:\n            return null;\n    }\n}\nfunction getPosition(board, position) {\n    try {\n        return board[position.x][position.y];\n    }\n    catch (e) {\n        log('Error getting position:', position, ' \\n board:', board);\n        throw new Error('Error getting position');\n    }\n}\nfunction setPosition(board, position) {\n    try {\n        board[position.x][position.y] = position;\n        return board;\n    }\n    catch (e) {\n        log('Error getting position: ', position);\n        throw new Error('Error getting position');\n    }\n}\nfunction setPieceOnBoard(board, position, isBlack) {\n    return setPosition(board, Position.setPiece(position, isBlack));\n}\nfunction removePieceOnBoard(board, position) {\n    return setPosition(board, Position.removePiece(position));\n}\nfunction clean(board) {\n    return mapBoard(board, position => {\n        position.iCanGoHere = false;\n        position.lastMove = false;\n        position.lastMoveJump = false;\n        return position;\n    });\n}\nfunction getPositionsWhereCanIGo(board, from, isBlack) {\n    if (!from)\n        return null;\n    const allNearPositions = getNearPositions(board, from, undefined);\n    const positions = [];\n    const orderedPositions = [];\n    for (let i = 0; i < allNearPositions.length; i++) {\n        const nearPosition = allNearPositions[i];\n        if (Position.hasNoPiece(nearPosition)) {\n            positions.push(nearPosition);\n            const y = getY0Start7End(nearPosition.y, isBlack);\n            if (!orderedPositions[y])\n                orderedPositions[y] = [];\n            orderedPositions[y][getToSearchOrder(nearPosition.x)] = nearPosition;\n        }\n        else {\n            const jumpPosition = getJumpPosition(board, from, nearPosition);\n            if (jumpPosition) {\n                jumpPosition.jumps = 1;\n                positions.push(jumpPosition);\n                const y = getY0Start7End(jumpPosition.y, isBlack);\n                if (!orderedPositions[y])\n                    orderedPositions[y] = [];\n                orderedPositions[y][getToSearchOrder(jumpPosition.x)] = jumpPosition;\n                whereCanIJump(board, jumpPosition, positions, orderedPositions, isBlack);\n            }\n        }\n    }\n    return {\n        positions,\n        orderedPositions\n    };\n}\nfunction getNearPositions(board, position, onlyEmpty) {\n    const positions = [];\n    function add(plusX, plusY) {\n        var newPosition = {\n            x: position.x + plusX,\n            y: position.y + plusY\n        };\n        if (!hasPosition(board, newPosition))\n            return;\n        newPosition = getPosition(board, newPosition);\n        if (typeof onlyEmpty !== 'undefined') {\n            if (onlyEmpty === Position.hasNoPiece(newPosition))\n                positions.push(newPosition);\n        }\n        else\n            positions.push(newPosition);\n    }\n    add(-1, -1);\n    add(0, -1);\n    add(+1, -1);\n    add(-1, 0);\n    add(+1, 0);\n    add(-1, +1);\n    add(0, +1);\n    add(+1, +1);\n    return positions;\n}\nfunction getJumpPosition(board, from, toJumpPosition) {\n    var jumpPosition = { x: 0, y: 0 };\n    if (from.x < toJumpPosition.x)\n        jumpPosition.x = toJumpPosition.x + 1;\n    else if (from.x > toJumpPosition.x)\n        jumpPosition.x = toJumpPosition.x - 1;\n    else\n        jumpPosition.x = toJumpPosition.x;\n    if (from.y < toJumpPosition.y)\n        jumpPosition.y = toJumpPosition.y + 1;\n    else if (from.y > toJumpPosition.y)\n        jumpPosition.y = toJumpPosition.y - 1;\n    else\n        jumpPosition.y = toJumpPosition.y;\n    if (!hasPosition(board, jumpPosition)) {\n        return;\n    }\n    jumpPosition = getPosition(board, jumpPosition);\n    if (Position.hasPiece(jumpPosition)) {\n        return;\n    }\n    return jumpPosition;\n}\n// tslint:disable-next-line:max-line-length\nfunction whereCanIJump(board, jumpfrom, positions, orderedPositions, isBlack) {\n    const nearFilledPositions = getNearPositions(board, jumpfrom, false);\n    nearFilledPositions.forEach(nearFilledPosition => {\n        const jumpPosition = getJumpPosition(board, jumpfrom, nearFilledPosition);\n        if (jumpPosition) {\n            if (Positions.notContains(positions, jumpPosition)) {\n                jumpPosition.lastPosition = jumpfrom;\n                jumpPosition.jumpingBlackPiece = nearFilledPosition.isBlack;\n                jumpPosition.jumps = jumpfrom.jumps ? jumpfrom.jumps++ : 2;\n                positions.push(jumpPosition);\n                const y = getY0Start7End(jumpPosition.y, isBlack);\n                if (!orderedPositions[y])\n                    orderedPositions[y] = [];\n                orderedPositions[y][getToSearchOrder(jumpPosition.x)] = jumpPosition;\n                whereCanIJump(board, jumpPosition, positions, orderedPositions, isBlack);\n            }\n        }\n    });\n}\nfunction setWhereCanIGo(board, from, blackPiece) {\n    const positions = getPositionsWhereCanIGo(board, from, blackPiece).positions;\n    return mapBoard(board, position => {\n        position.iCanGoHere = Positions.contains(positions, position);\n        return position;\n    });\n}\nfunction printUnicode(board) {\n    var txt = '';\n    for (var y = 0; y < board.length; y++) {\n        for (var x = 0; x < board[y].length; x++) {\n            const position = board[x][y];\n            if (isBackGroundBlack(x, y)) {\n                if (Position.hasWhitePiece(position))\n                    txt += '\\u{25CF}';\n                else if (Position.hasBlackPiece(position))\n                    txt += '\\u{25CB}';\n                else\n                    txt += ' ';\n            }\n            else {\n                if (Position.hasWhitePiece(position))\n                    txt += '\\u{25D9}';\n                else if (Position.hasBlackPiece(position))\n                    txt += '\\u{25D8}';\n                else\n                    txt += '\\u{2588}';\n            }\n        }\n        txt += '\\n';\n    }\n    return txt;\n}\nfunction getBoardAfterMove(board, move) {\n    move.to.lastMove = true;\n    move.from.lastMove = true;\n    board = setPieceOnBoard(board, move.to, Position.hasBlackPiece(move.from));\n    board = removePieceOnBoard(board, move.from);\n    let jumpPosition = move.to.lastPosition;\n    while (jumpPosition) {\n        getPosition(board, jumpPosition).lastMoveJump = true;\n        jumpPosition = jumpPosition.lastPosition;\n    }\n    return board;\n}\nexport { defaultBoardSize, defaultBoardConf, defaultInitialBoard, getBoardAfterMove, clean, getInitialBoard, getToSearchOrder, getBoardConf, getColorStartEndRow, getJumpPosition, getNearPositions, getPosition, getPositionsWhereCanIGo, getY0Start7End, getY7Start0End, isBackGroundBlack, printUnicode, whereCanIJump, setPosition, setWhereCanIGo, hasPosition };\n//# sourceMappingURL=Board.js.map"]}