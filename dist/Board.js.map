{"version":3,"sources":["../dist-esnext/Board.js"],"names":["Position","defaultBoardSize","x","y","hasPositionByBoardSize","boardSize","position","hasPosition","board","getBoardSize","mapBoard","func","map","col","p","getStartEndRow","boardEndRow","isBlack","startRow","endRow","getStartEndRowsFromBoardSize","white","black","getStartEndRows","compose","createCols","cols","concat","createRows","rows","_getCleanBoard","memoize","getCleanBoard","getBoardWithPieces","pieces","piece","getPositionFromPositions","removePiece","setPiece","getStartWhiteBlack","whiteY","addStartPieces","positions","getStartPieces","_getInitialBoard","getInitialBoard","getPosition","e","Error","setPosition","hasSameXY","setPieceOnBoard","removePieceOnBoard","getBoardSizeX","length","getBoardSizeY","printBoard","printPosition","reduce","txtRow","txt","printBoardCurried","curry","printUnicodeBoard","printUnicodePosition","printXAndYBoard","printXAndYPosition","whereCanIJump","from","nearPieces","getNotEmptyNearPositions","accPositions","nearPiece","jumpTo","getJumpPosition","containsXY","lastPosition","jumpingBlackPiece","jumps","getPositionsWhereCanIGo","allNearPositions","getNearPositions","nearPosition","hasNoPiece","getAllNearPositions","toAdd","_getNearPositions","xy","filter","getXAndY","getEmptyNearPositions","hasPiece","getJump","toJump","getJumpXY","jumpXY","jumpPosition","getBoardWhereCanIGo","setICanGoHere","getPiecesFromBoard","initialPieces","piecesRow","row","hasBlackPiece","hasWhitePiece"],"mappings":"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","file":"Board.js","sourcesContent":["import R from 'ramda';\nimport * as Position from './Position';\n/**\n * Default 8x8 board size\n */\nconst defaultBoardSize = { x: 8, y: 8 };\n/**\n * Checks if position exists in this board size\n */\nconst hasPositionByBoardSize = (boardSize, position) => position\n    && position.x >= 0 && position.y >= 0\n    && boardSize.y > position.y && boardSize.x > position.x;\n/**\n * Check if position exists on board\n */\nconst hasPosition = (board, position) => hasPositionByBoardSize(getBoardSize(board), position);\n/**\n * Map some function in all board positions and return a new board\n */\nconst mapBoard = (board, func) => board.map(col => col.map(p => func(p)));\n/**\n * Get START and END rows\n *\n * returns { startRow, endRow }\n */\nfunction getStartEndRow(boardEndRow, isBlack) {\n    return {\n        startRow: isBlack ? 0 : boardEndRow,\n        endRow: isBlack ? boardEndRow : 0\n    };\n}\n/**\n * Takes a boardSize and return START and END rows for WHITE and BLACK.\n *\n * returns { white:{startRow, endRow}, black:{startRow, endRow} }\n */\nfunction getStartEndRowsFromBoardSize(boardSize) {\n    const endRow = boardSize.y - 1;\n    return {\n        white: getStartEndRow(endRow, false),\n        black: getStartEndRow(endRow, true)\n    };\n}\n/**\n * Takes a board and return START and END rows for WHITE and BLACK.\n *\n * returns { white:{startRow, endRow}, black:{startRow, endRow} }\n */\nconst getStartEndRows = R.compose(getStartEndRowsFromBoardSize, getBoardSize);\n/**\n * Create cols recursively\n */\nconst createCols = (x, y, cols) => x < 0 ? cols : createCols(x - 1, y, R.concat([{ x, y }], cols || []));\n/**\n * Create rows recursively\n */\nconst createRows = (x, y, rows) => y < 0 ? rows : createRows(x, y - 1, R.concat([createCols(x, y)], rows || []));\n/**\n * Get cached clean board, using memoize from ramda\n *\n * The _getCleanBoard returns :Function Type,\n * that's why we created getCleanBoard witch returns :IPosition[y][x]\n * in order to reduce type errors.\n */\n// tslint:disable-next-line:variable-name\nconst _getCleanBoard = R.memoize((boardSize) => createRows(boardSize.x - 1, boardSize.y - 1));\n/**\n * Get cached clean board, using memoize from ramda\n */\nfunction getCleanBoard(boardSize) {\n    return _getCleanBoard(boardSize);\n}\nfunction getBoardWithPieces(board, pieces) {\n    return mapBoard(board, position => {\n        const piece = Position.getPositionFromPositions(pieces, position);\n        if (!piece)\n            return Position.removePiece(position);\n        return Position.setPiece(piece.isBlack, position);\n    });\n}\n/**\n * Get start white and black pieces\n */\nconst getStartWhiteBlack = (x, whiteY) => [\n    { x, y: 0, isBlack: true },\n    { x, y: whiteY, isBlack: false }\n];\n/**\n * Add start pieces recursively\n */\nconst addStartPieces = (x, whiteY, positions) => x < 0\n    ? positions\n    : addStartPieces(x - 1, whiteY, positions.concat(getStartWhiteBlack(x, whiteY)));\n/**\n * Get start white and black pieces\n */\nfunction getStartPieces(boardSize) {\n    return addStartPieces(boardSize.x - 1, boardSize.y - 1, []);\n}\n/**\n * Get cached initial board, using memoize from ramda\n *\n * The _getInitialBoard returns :Function Type,\n * that's why we created getInitialBoard witch returns :IPosition[y][x]\n * in order to reduce type errors.\n */\n// tslint:disable-next-line:variable-name\nconst _getInitialBoard = R.memoize((boardSize) => getBoardWithPieces(getCleanBoard(boardSize), getStartPieces(boardSize)));\n/**\n * Get cached initial board, using memoize from ramda\n */\nfunction getInitialBoard(boardSize) {\n    return _getInitialBoard(boardSize);\n}\nfunction getPosition(board, position) {\n    try {\n        return board[position.y][position.x];\n    }\n    catch (e) {\n        throw new Error('Error getting position');\n    }\n}\nconst setPosition = (board, position) => mapBoard(board, p => Position.hasSameXY(p, position) ? position : p);\nconst setPieceOnBoard = (board, position, isBlack) => setPosition(board, Position.setPiece(isBlack, position));\nconst removePieceOnBoard = (board, position) => setPosition(board, Position.removePiece(position));\n/**\n * Take a board: I.IPosition[][] an return the number of rows(X)\n */\nconst getBoardSizeX = (board) => board[0].length;\n/**\n * Take a board: I.IPosition[][] an return the number of rows(Y)\n */\nconst getBoardSizeY = (board) => board.length;\n/**\n * Take a board: I.IPosition[][] an return the number of columns and rows {x, y}\n */\nfunction getBoardSize(board) {\n    return {\n        x: getBoardSizeX(board),\n        y: getBoardSizeY(board)\n    };\n}\n/**\n * Takes a function to printPosition and print board.\n */\nfunction printBoard(printPosition, board) {\n    return board.reduce((txtRow, col) => {\n        return col.reduce((txt, position) => {\n            return txt + printPosition(position);\n        }, txtRow) + '\\n';\n    }, '');\n}\nconst printBoardCurried = R.curry(printBoard);\n/**\n * Get board in a nice format to print it on console\n */\nconst printUnicodeBoard = printBoardCurried(Position.printUnicodePosition);\n/**\n * Prints only X and Y positions of a board.\n */\nconst printXAndYBoard = printBoardCurried(Position.printXAndYPosition);\n/**\n * Gets all positions where can I jump recursively.\n * 1. Get not empty near positions from board.\n * 2. Foreach not empty near position:\n *  - Get jump position.\n *  - If jump position do NOT exists or accumulated positions\n *      contains jump position then return accumulated positions.\n *  - Set last position equals from.\n *  - Set Jumping black piece to true if is black piece.\n *  - Set Jumps to from jumps +1.\n *  - Call and return this method again recursively to get next jump positions.\n */\nfunction whereCanIJump(board, from, isBlack, positions) {\n    const nearPieces = getNotEmptyNearPositions(board, from);\n    return nearPieces.reduce((accPositions, nearPiece) => {\n        const jumpTo = getJumpPosition(from, nearPiece, board);\n        if (!jumpTo || Position.containsXY(accPositions, jumpTo))\n            return accPositions;\n        jumpTo.lastPosition = from;\n        jumpTo.jumpingBlackPiece = nearPiece.isBlack;\n        jumpTo.jumps = from.jumps ? from.jumps + 1 : 2;\n        return whereCanIJump(board, jumpTo, isBlack, accPositions.concat(jumpTo));\n    }, positions || []);\n}\n/**\n * Gets all near positions and reduce. Foreach near position checks:\n *  - Has no piece: concat positions and return.\n *  - Has piece:\n *      1. Get jump position, if jump position do not exists return prev positions.\n *      2. Concat jump to positions then call whereCanIJump() and return it.\n */\nfunction getPositionsWhereCanIGo(board, from, isBlack) {\n    if (!from)\n        return null;\n    const allNearPositions = getNearPositions(board, from);\n    return allNearPositions.reduce((positions, nearPosition) => {\n        if (Position.hasNoPiece(nearPosition))\n            return positions.concat(nearPosition);\n        const jumpTo = getJumpPosition(from, nearPosition, board);\n        if (!jumpTo)\n            return positions;\n        jumpTo.jumps = 1;\n        return whereCanIJump(board, jumpTo, isBlack, positions.concat(jumpTo));\n    }, []);\n}\n/**\n * Get all valid and invalid near positions.\n */\nfunction getAllNearPositions(position) {\n    return [\n        [-1, -1],\n        [0, -1],\n        [1, -1],\n        [-1, 0],\n        [1, 0],\n        [-1, 1],\n        [0, 1],\n        [1, 1]\n    ].map(toAdd => {\n        return {\n            x: position.x + toAdd[0],\n            y: position.y + toAdd[1]\n        };\n    });\n}\n/**\n * Get near positions and CACHES it for each boardSize\n */\n// tslint:disable-next-line:variable-name\nconst _getNearPositions = R.memoize((boardSize, xy) => getAllNearPositions(xy)\n    .filter(p => hasPositionByBoardSize(boardSize, p)));\n/**\n * Get all near positions from the given board instance.\n */\nfunction getNearPositions(board, position) {\n    return _getNearPositions(getBoardSize(board), Position.getXAndY(position))\n        .map(p => getPosition(board, p));\n}\n/**\n * Get empty near positions\n */\nconst getEmptyNearPositions = (board, position) => getNearPositions(board, position)\n    .filter(p => Position.hasNoPiece(p));\n/**\n * Get not empty near positions\n */\nconst getNotEmptyNearPositions = (board, position) => getNearPositions(board, position)\n    .filter(p => Position.hasPiece(p));\n/**\n * Takes from position (x or y) and to jump position (x or y) then returns the x or y of the target position.\n */\nfunction getJump(from, toJump) {\n    if (from < toJump)\n        return toJump + 1;\n    else if (from > toJump)\n        return toJump - 1;\n    else\n        return toJump;\n}\n/**\n * Returns the target position from a jump.\n */\nfunction getJumpXY(from, toJump) {\n    return {\n        x: getJump(from.x, toJump.x),\n        y: getJump(from.y, toJump.y)\n    };\n}\n/**\n * Returns the target board position from a jump if this position exists and is empty.\n */\nfunction getJumpPosition(from, toJump, board) {\n    const jumpXY = getJumpXY(from, toJump);\n    if (!hasPosition(board, jumpXY))\n        return;\n    const jumpPosition = getPosition(board, jumpXY);\n    if (Position.hasPiece(jumpPosition))\n        return;\n    return jumpPosition;\n}\n/**\n * Get board with checked where can I go positions\n */\nfunction getBoardWhereCanIGo(board, from, isBlack) {\n    const positions = getPositionsWhereCanIGo(board, from, isBlack);\n    return mapBoard(board, position => Position.setICanGoHere(positions, position));\n}\n/**\n * Takes a board and return white and black pieces.\n * Used to calculate score from a board.\n *\n * returns { white: [{x,y}], black: [{x,y}] }\n */\nfunction getPiecesFromBoard(board) {\n    const initialPieces = {\n        white: [],\n        black: []\n    };\n    return board.reduce((piecesRow, row) => {\n        return row.reduce((pieces, position) => {\n            if (Position.hasBlackPiece(position))\n                pieces.black = pieces.black.concat(position);\n            else if (Position.hasWhitePiece(position))\n                pieces.white = pieces.white.concat(position);\n            return pieces;\n        }, piecesRow);\n    }, initialPieces);\n}\nexport { _getCleanBoard, _getInitialBoard, _getNearPositions, defaultBoardSize, getInitialBoard, getBoardWithPieces, getBoardWhereCanIGo, getCleanBoard, getStartEndRow, getStartEndRows, getStartPieces, getEmptyNearPositions, getJumpPosition, getNearPositions, getNotEmptyNearPositions, getPosition, getPositionsWhereCanIGo, getPiecesFromBoard, printBoard, printBoardCurried, printUnicodeBoard, printXAndYBoard, whereCanIJump, setPieceOnBoard, setPosition, removePieceOnBoard, hasPosition, hasPositionByBoardSize };\n//# sourceMappingURL=Board.js.map"]}