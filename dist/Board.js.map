{"version":3,"sources":["../dist-esnext/Board.js"],"names":["Position","defaultBoardSize","x","y","hasPositionByBoardSize","boardSize","position","hasPosition","board","getBoardSize","mapBoard","func","map","col","p","getStartEndRow","boardEndRow","isBlack","startRow","endRow","getStartEndRowsFromBoardSize","white","black","getStartEndRows","compose","_getInitialBoard","memoize","getInitialBoard","getPosition","e","Error","setPosition","hasSameXY","setPieceOnBoard","setPiece","removePieceOnBoard","removePiece","getBoardSizeX","length","getBoardSizeY","printBoard","printPosition","reduce","txtRow","txt","printBoardCurried","curry","printUnicodeBoard","printUnicodePosition","printXAndYBoard","printXAndYPosition","getPositionsWhereCanIGo","from","allNearPositions","getNearPositions","positions","orderedPositions","i","nearPosition","hasNoPiece","push","getY0Start","getToSearchOrder","jumpPosition","getJumpPosition","jumps","whereCanIJump","getAllNearPositions","toAdd","_getNearPositions","xy","filter","getXAndY","getEmptyNearPositions","getNotEmptyNearPositions","hasPiece","getJump","toJump","getJumpXY","jumpXY","jumpFrom","nearFilledPositions","forEach","nearFilledPosition","notContainsXY","lastPosition","jumpingBlackPiece","getBoardWhereCanIGo","setICanGoHere","getPiecesFromBoard","initialPieces","piecesRow","row","pieces","hasBlackPiece","concat","hasWhitePiece"],"mappings":"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","file":"Board.js","sourcesContent":["import R from 'ramda';\nimport * as Position from './Position';\nimport log from 'ptz-log';\n/**\n * Default 8x8 board size\n */\nconst defaultBoardSize = { x: 8, y: 8 };\n/**\n * Checks if position exists in this board size\n */\nconst hasPositionByBoardSize = (boardSize, position) => position\n    && position.x >= 0 && position.y >= 0\n    && boardSize.y > position.y && boardSize.x > position.x;\n/**\n * Check if position exists on board\n */\nconst hasPosition = (board, position) => hasPositionByBoardSize(getBoardSize(board), position);\n/**\n * Map some function in all board positions and return a new board\n */\nconst mapBoard = (board, func) => board.map(col => col.map(p => func(p)));\n/**\n * Get START and END rows\n *\n * returns { startRow, endRow }\n */\nfunction getStartEndRow(boardEndRow, isBlack) {\n    return {\n        startRow: isBlack ? 0 : boardEndRow,\n        endRow: isBlack ? boardEndRow : 0\n    };\n}\n/**\n * Takes a boardSize and return START and END rows for WHITE and BLACK.\n *\n * returns { white:{startRow, endRow}, black:{startRow, endRow} }\n */\nfunction getStartEndRowsFromBoardSize(boardSize) {\n    const endRow = boardSize.y - 1;\n    return {\n        white: getStartEndRow(endRow, false),\n        black: getStartEndRow(endRow, true)\n    };\n}\n/**\n * Takes a board and return START and END rows for WHITE and BLACK.\n *\n * returns { white:{startRow, endRow}, black:{startRow, endRow} }\n */\nconst getStartEndRows = R.compose(getStartEndRowsFromBoardSize, getBoardSize);\n/**\n * Get cached initial board, using memoize from ramda\n *\n * The _getInitialBoard returns :Function Type,\n * that's why we created getInitialBoard witch returns :IGetInitialBoardResult\n * in order to reduce type errors.\n */\n// tslint:disable-next-line:variable-name\nconst _getInitialBoard = R.memoize((boardSize) => {\n    // Do NOT remove the log below. We use it to check if cache works and this code run once.\n    log('--> You MUST see this msg only once, otherwise memoize is not working <-- \\n _getInitialBoard for', boardSize);\n    const endRow = boardSize.y - 1;\n    const board = [];\n    for (let x = 0; x < boardSize.x; x++) {\n        for (let y = 0; y < boardSize.y; y++) {\n            if (!board[y])\n                board[y] = [];\n            const position = { x, y };\n            if (y === 0)\n                position.isBlack = true;\n            if (y === endRow)\n                position.isBlack = false;\n            board[y][x] = position;\n        }\n    }\n    return board;\n});\n/**\n * Get cached initial board, using memoize from ramda\n */\nfunction getInitialBoard(boardSize) {\n    return _getInitialBoard(boardSize);\n}\nfunction getPosition(board, position) {\n    try {\n        return board[position.y][position.x];\n    }\n    catch (e) {\n        throw new Error('Error getting position');\n    }\n}\nconst setPosition = (board, position) => mapBoard(board, p => Position.hasSameXY(p, position) ? position : p);\nconst setPieceOnBoard = (board, position, isBlack) => setPosition(board, Position.setPiece(isBlack, position));\nconst removePieceOnBoard = (board, position) => setPosition(board, Position.removePiece(position));\n/**\n * Take a board: I.IPosition[][] an return the number of rows(X)\n */\nconst getBoardSizeX = (board) => board[0].length;\n/**\n * Take a board: I.IPosition[][] an return the number of rows(Y)\n */\nconst getBoardSizeY = (board) => board.length;\n/**\n * Take a board: I.IPosition[][] an return the number of columns and rows {x, y}\n */\nfunction getBoardSize(board) {\n    return {\n        x: getBoardSizeX(board),\n        y: getBoardSizeY(board)\n    };\n}\n/**\n * Takes a function to printPosition and print board.\n */\nfunction printBoard(printPosition, board) {\n    return board.reduce((txtRow, col) => {\n        return col.reduce((txt, position) => {\n            return txt + printPosition(position);\n        }, txtRow) + '\\n';\n    }, '');\n}\nconst printBoardCurried = R.curry(printBoard);\n/**\n * Get board in a nice format to print it on console\n */\nconst printUnicodeBoard = printBoardCurried(Position.printUnicodePosition);\n/**\n * Prints only X and Y positions of a board.\n */\nconst printXAndYBoard = printBoardCurried(Position.printXAndYPosition);\nfunction getPositionsWhereCanIGo(board, from, isBlack) {\n    if (!from)\n        return null;\n    const allNearPositions = getNearPositions(board, from);\n    const positions = [];\n    const orderedPositions = [];\n    for (let i = 0; i < allNearPositions.length; i++) {\n        const nearPosition = allNearPositions[i];\n        if (Position.hasNoPiece(nearPosition)) {\n            positions.push(nearPosition);\n            const y = Position.getY0Start(getBoardSizeY(board), nearPosition.y, isBlack);\n            if (!orderedPositions[y])\n                orderedPositions[y] = [];\n            orderedPositions[y][Position.getToSearchOrder(getBoardSize(board), nearPosition.x)] = nearPosition;\n        }\n        else {\n            const jumpPosition = getJumpPosition(from, nearPosition, board);\n            if (jumpPosition) {\n                jumpPosition.jumps = 1;\n                positions.push(jumpPosition);\n                const y = Position.getY0Start(getBoardSizeY(board), jumpPosition.y, isBlack);\n                if (!orderedPositions[y])\n                    orderedPositions[y] = [];\n                orderedPositions[y][Position.getToSearchOrder(getBoardSize(board), jumpPosition.x)] = jumpPosition;\n                whereCanIJump(board, jumpPosition, positions, orderedPositions, isBlack);\n            }\n        }\n    }\n    return {\n        positions,\n        orderedPositions\n    };\n}\n/**\n * Get all valid and invalid near positions.\n */\nfunction getAllNearPositions(position) {\n    return [\n        [-1, -1],\n        [0, -1],\n        [1, -1],\n        [-1, 0],\n        [1, 0],\n        [-1, 1],\n        [0, 1],\n        [1, 1]\n    ].map(toAdd => {\n        return {\n            x: position.x + toAdd[0],\n            y: position.y + toAdd[1]\n        };\n    });\n}\n/**\n * Get near positions and CACHES it for each boardSize\n */\n// tslint:disable-next-line:variable-name\nconst _getNearPositions = R.memoize((boardSize, xy) => getAllNearPositions(xy)\n    .filter(p => hasPositionByBoardSize(boardSize, p)));\n/**\n * Get all near positions from the given board instance.\n */\nfunction getNearPositions(board, position) {\n    return _getNearPositions(getBoardSize(board), Position.getXAndY(position))\n        .map(p => getPosition(board, p));\n}\n/**\n * Get empty near positions\n */\nconst getEmptyNearPositions = (board, position) => getNearPositions(board, position)\n    .filter(p => Position.hasNoPiece(p));\n/**\n * Get not empty near positions\n */\nconst getNotEmptyNearPositions = (board, position) => getNearPositions(board, position)\n    .filter(p => Position.hasPiece(p));\n/**\n * Takes from position (x or y) and to jump position (x or y) then returns the x or y of the target position.\n */\nfunction getJump(from, toJump) {\n    if (from < toJump)\n        return toJump + 1;\n    else if (from > toJump)\n        return toJump - 1;\n    else\n        return toJump;\n}\nfunction getJumpXY(from, toJump) {\n    return {\n        x: getJump(from.x, toJump.x),\n        y: getJump(from.y, toJump.y)\n    };\n}\n/**\n * Returns the target position from a jump if this position exists and is empty.\n */\nfunction getJumpPosition(from, toJump, board) {\n    const jumpXY = getJumpXY(from, toJump);\n    if (!hasPosition(board, jumpXY))\n        return;\n    const jumpPosition = getPosition(board, jumpXY);\n    if (Position.hasPiece(jumpPosition))\n        return;\n    return jumpPosition;\n}\n// tslint:disable-next-line:max-line-length\nfunction whereCanIJump(board, jumpFrom, positions, orderedPositions, isBlack) {\n    const nearFilledPositions = getNotEmptyNearPositions(board, jumpFrom);\n    nearFilledPositions.forEach(nearFilledPosition => {\n        const jumpPosition = getJumpPosition(jumpFrom, nearFilledPosition, board);\n        if (jumpPosition) {\n            if (Position.notContainsXY(positions, jumpPosition)) {\n                jumpPosition.lastPosition = jumpFrom;\n                jumpPosition.jumpingBlackPiece = nearFilledPosition.isBlack;\n                jumpPosition.jumps = jumpFrom.jumps ? jumpFrom.jumps++ : 2;\n                positions.push(jumpPosition);\n                const y = Position.getY0Start(getBoardSizeY(board), jumpPosition.y, isBlack);\n                if (!orderedPositions[y])\n                    orderedPositions[y] = [];\n                orderedPositions[y][Position.getToSearchOrder(getBoardSize(board), jumpPosition.x)] = jumpPosition;\n                whereCanIJump(board, jumpPosition, positions, orderedPositions, isBlack);\n            }\n        }\n    });\n}\n/**\n * Get board with checked where can I go positions\n */\nfunction getBoardWhereCanIGo(board, from, isBlack) {\n    const { positions } = getPositionsWhereCanIGo(board, from, isBlack);\n    return mapBoard(board, position => Position.setICanGoHere(positions, position));\n}\n/**\n * Takes a board and return white and black pieces.\n * Used to calculate score from a board.\n *\n * returns { white: [{x,y}], black: [{x,y}] }\n */\nfunction getPiecesFromBoard(board) {\n    const initialPieces = {\n        white: [],\n        black: []\n    };\n    return board.reduce((piecesRow, row) => {\n        return row.reduce((pieces, position) => {\n            if (Position.hasBlackPiece(position))\n                pieces.black = pieces.black.concat(position);\n            else if (Position.hasWhitePiece(position))\n                pieces.white = pieces.white.concat(position);\n            return pieces;\n        }, piecesRow);\n    }, initialPieces);\n}\nexport { _getInitialBoard, _getNearPositions, defaultBoardSize, getInitialBoard, getBoardWhereCanIGo, getStartEndRow, getStartEndRows, getEmptyNearPositions, getJumpPosition, getNearPositions, getNotEmptyNearPositions, getPosition, getPositionsWhereCanIGo, getPiecesFromBoard, printBoard, printBoardCurried, printUnicodeBoard, printXAndYBoard, whereCanIJump, setPieceOnBoard, setPosition, removePieceOnBoard, hasPosition, hasPositionByBoardSize };\n//# sourceMappingURL=Board.js.map"]}