{"version":3,"sources":["../dist-esnext/Board.js"],"names":["Position","defaultBoardSize","x","y","hasPositionByBoardSize","boardSize","position","hasPosition","board","getBoardSize","mapBoard","func","map","col","p","getStartEndRow","boardEndRow","isBlack","startRow","endRow","getStartEndRowsFromBoardSize","white","black","getStartEndRows","compose","createCol","createRow","boardSizeX","range","_getCleanBoard","memoize","getCleanBoard","getBoardWithPieces","pieces","piece","getPositionFromPositions","getStartWhiteBlack","whiteY","addStartPieces","positions","concat","getStartPieces","_getInitialBoard","getInitialBoard","getPositionFromBoard","e","Error","getPositionsFromBoard","getBoardSizeX","length","getBoardSizeY","printBoard","curry","printPosition","reduce","txtRow","txt","printUnicodeBoard","printUnicodePosition","printXAndYBoard","printXAndYPosition","whereCanIJump","from","nearPieces","getNotEmptyNearPositions","accPositions","nearPiece","jumpTo","getJumpPosition","containsXY","jumpingBlackPiece","jumps","getPositionsWhereCanIGo","allNearPositions","getNearPositions","nearPosition","hasNoPiece","getPiecesWhereCanIGo","whereCanIGo","getAllNearPositions","toAdd","_getNearPositions","xy","filter","nearPositions","getXAndY","getEmptyNearPositions","hasPiece","getJump","toJump","getJumpXY","jumpXY","jumpPosition","getBoardWhereCanIGo","setICanGoHere","getPiecesFromBoard","initialPieces","piecesRow","row","hasBlackPiece","hasWhitePiece"],"mappings":"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","file":"Board.js","sourcesContent":["import R from 'ramda';\nimport * as Position from './Position';\n/**\n * Default 8x8 board size\n */\nconst defaultBoardSize = { x: 8, y: 8 };\n/**\n * Checks if position exists in this board size\n */\nconst hasPositionByBoardSize = (boardSize, position) => position\n    && position.x >= 0 && position.y >= 0\n    && boardSize.y > position.y && boardSize.x > position.x;\n/**\n * Check if position exists on board\n */\nconst hasPosition = (board, position) => hasPositionByBoardSize(getBoardSize(board), position);\n/**\n * Map some function in all board positions and return a new board\n */\nconst mapBoard = (board, func) => board.map(col => col.map(p => func(p)));\n/**\n * Get START and END rows\n *\n * returns { startRow, endRow }\n */\nfunction getStartEndRow(boardEndRow, isBlack) {\n    return {\n        startRow: isBlack ? 0 : boardEndRow,\n        endRow: isBlack ? boardEndRow : 0\n    };\n}\n/**\n * Takes a boardSize and return START and END rows for WHITE and BLACK.\n *\n * returns { white:{startRow, endRow}, black:{startRow, endRow} }\n */\nfunction getStartEndRowsFromBoardSize(boardSize) {\n    const endRow = boardSize.y - 1;\n    return {\n        white: getStartEndRow(endRow, false),\n        black: getStartEndRow(endRow, true)\n    };\n}\n/**\n * Takes a board and return START and END rows for WHITE and BLACK.\n *\n * returns { white:{startRow, endRow}, black:{startRow, endRow} }\n */\nconst getStartEndRows = R.compose(getStartEndRowsFromBoardSize, getBoardSize);\n/**\n * Create position {x, y}\n */\nfunction createCol(x, y) {\n    return { x, y };\n}\n/**\n * Create positions row [{x,y},{x,y},{x,y}]\n */\nconst createRow = (boardSizeX, y) => R.range(0, boardSizeX).map(x => createCol(x, y));\n/**\n * Get cached clean board, using memoize from ramda.\n *\n * The _getCleanBoard returns :Function Type,\n * that's why we created getCleanBoard witch returns :IPosition[y][x]\n * in order to reduce type errors.\n */\n// tslint:disable-next-line:variable-name\nconst _getCleanBoard = R.memoize((boardSize) => R.range(0, boardSize.y)\n    .map(y => createRow(boardSize.x, y)));\n/**\n * Get cached clean board, using memoize from ramda.\n */\nfunction getCleanBoard(boardSize) {\n    return _getCleanBoard(boardSize);\n}\n/**\n * Takes a board and return a new board with pieces.\n */\nconst getBoardWithPieces = (board, pieces) => mapBoard(board, p => {\n    const { x, y } = p;\n    const piece = Position.getPositionFromPositions(pieces, p);\n    return piece\n        ? { x, y, isBlack: piece.isBlack }\n        : { x, y };\n});\n/**\n * Get start white and black pieces.\n */\nconst getStartWhiteBlack = (x, whiteY) => [\n    { x, y: 0, isBlack: true },\n    { x, y: whiteY, isBlack: false }\n];\n/**\n * Add start pieces recursively\n */\nconst addStartPieces = (x, whiteY, positions) => x < 0\n    ? positions\n    : addStartPieces(x - 1, whiteY, positions.concat(getStartWhiteBlack(x, whiteY)));\n/**\n * Get start white and black pieces\n */\nfunction getStartPieces(boardSize) {\n    return addStartPieces(boardSize.x - 1, boardSize.y - 1, []);\n}\n/**\n * Get cached initial board, using memoize from ramda\n *\n * The _getInitialBoard returns :Function Type,\n * that's why we created getInitialBoard witch returns :IPosition[y][x]\n * in order to reduce type errors.\n */\n// tslint:disable-next-line:variable-name\nconst _getInitialBoard = R.memoize((boardSize) => getBoardWithPieces(getCleanBoard(boardSize), getStartPieces(boardSize)));\n/**\n * Get cached initial board, using memoize from ramda.\n */\nfunction getInitialBoard(boardSize) {\n    return _getInitialBoard(boardSize);\n}\n/**\n * Gets board position from x and y coordinates.\n * @param board board to get the position.\n * @param position desired x,y position.\n */\nfunction getPositionFromBoard(board, position) {\n    try {\n        return board[position.y][position.x];\n    }\n    catch (e) {\n        throw new Error('Error getting position');\n    }\n}\n/**\n * Get the desired x,y positions from a board.\n * @param positions list of x,y positions.\n * @param board board to get the positions from.\n */\nconst getPositionsFromBoard = (board, positions) => positions.map(p => getPositionFromBoard(board, p));\n/**\n * Take a board: I.IPosition[][] an return the number of rows(X)\n */\nconst getBoardSizeX = (board) => board[0].length;\n/**\n * Take a board: I.IPosition[][] an return the number of rows(Y)\n */\nconst getBoardSizeY = (board) => board.length;\n/**\n * Take a board: I.IPosition[][] an return the number of columns and rows {x, y}\n */\nfunction getBoardSize(board) {\n    return {\n        x: getBoardSizeX(board),\n        y: getBoardSizeY(board)\n    };\n}\n/**\n * Takes a function to printPosition and print board.\n */\nconst printBoard = R.curry((printPosition, board) => board.reduce((txtRow, col) => {\n    return col.reduce((txt, position) => {\n        return txt + printPosition(position);\n    }, txtRow) + '\\n';\n}, ''));\n/**\n * Get board in a nice format to print it on console\n */\nconst printUnicodeBoard = printBoard(Position.printUnicodePosition);\n/**\n * Prints only X and Y positions of a board.\n */\nconst printXAndYBoard = printBoard(Position.printXAndYPosition);\n/**\n * Gets all positions where can I jump recursively.\n * 1. Get not empty near positions from board.\n * 2. Foreach not empty near position:\n *  - Get jump position.\n *  - If jump position do NOT exists or accumulated positions\n *      contains jump position then return accumulated positions.\n *  - Set Jumping black piece to true if is black piece.\n *  - Set Jumps to from + from.jumps.\n *  - Call and return this method again recursively to get next jump positions.\n */\nfunction whereCanIJump(board, from, positions) {\n    const nearPieces = getNotEmptyNearPositions(board, from);\n    return nearPieces.reduce((accPositions, nearPiece) => {\n        const jumpTo = getJumpPosition(from, nearPiece, board);\n        if (!jumpTo || Position.containsXY(accPositions, jumpTo))\n            return accPositions;\n        jumpTo.jumpingBlackPiece = nearPiece.isBlack;\n        jumpTo.jumps = (from.jumps || []).concat(from);\n        return whereCanIJump(board, jumpTo, accPositions.concat(jumpTo));\n    }, positions || []);\n}\n/**\n * Gets all near positions and reduce. Foreach near position checks:\n *  - Has no piece: concat positions and return.\n *  - Has piece:\n *      1. Get jump position, if jump position do not exists return prev positions.\n *      2. Concat jump to positions then call whereCanIJump() and return it.\n */\nfunction getPositionsWhereCanIGo(board, from) {\n    if (!from)\n        return null;\n    const allNearPositions = getNearPositions(board, from);\n    return allNearPositions.reduce((positions, nearPosition) => {\n        if (Position.hasNoPiece(nearPosition))\n            return positions.concat(nearPosition);\n        const jumpTo = getJumpPosition(from, nearPosition, board);\n        if (!jumpTo)\n            return positions;\n        return whereCanIJump(board, jumpTo, positions.concat(jumpTo));\n    }, []);\n}\n/**\n * Gets all pieces with whereCanIGo positions.\n */\nfunction getPiecesWhereCanIGo(board, positions) {\n    return positions.map(position => {\n        const { x, y, isBlack } = position;\n        return {\n            x, y, isBlack,\n            whereCanIGo: getPositionsWhereCanIGo(board, position)\n        };\n    });\n}\n/**\n * Get all valid and invalid near positions.\n */\nconst getAllNearPositions = (position) => [\n    [-1, -1], [0, -1], [1, -1],\n    [-1, 0], [1, 0],\n    [-1, 1], [0, 1], [1, 1] // Below positions\n].map(toAdd => {\n    return {\n        x: position.x + toAdd[0],\n        y: position.y + toAdd[1]\n    };\n});\n/**\n * Get near positions and CACHES it for each boardSize\n */\n// tslint:disable-next-line:variable-name\nconst _getNearPositions = R.memoize((boardSize, xy) => getAllNearPositions(xy).filter(p => hasPositionByBoardSize(boardSize, p)));\n/**\n * Get all near positions from the given board instance.\n */\nfunction getNearPositions(board, position) {\n    const nearPositions = _getNearPositions(getBoardSize(board), Position.getXAndY(position));\n    return getPositionsFromBoard(board, nearPositions);\n}\n/**\n * Get empty near positions\n */\nconst getEmptyNearPositions = (board, position) => getNearPositions(board, position)\n    .filter(p => Position.hasNoPiece(p));\n/**\n * Get not empty near positions\n */\nconst getNotEmptyNearPositions = (board, position) => getNearPositions(board, position)\n    .filter(p => Position.hasPiece(p));\n/**\n * Takes from position (x or y) and to jump position (x or y) then returns the x or y of the target position.\n */\nfunction getJump(from, toJump) {\n    if (from < toJump)\n        return toJump + 1;\n    else if (from > toJump)\n        return toJump - 1;\n    else\n        return toJump;\n}\n/**\n * Returns the target position from a jump.\n */\nfunction getJumpXY(from, toJump) {\n    return {\n        x: getJump(from.x, toJump.x),\n        y: getJump(from.y, toJump.y)\n    };\n}\n/**\n * Returns the target board position from a jump if this position exists and is empty.\n */\nfunction getJumpPosition(from, toJump, board) {\n    const jumpXY = getJumpXY(from, toJump);\n    if (!hasPosition(board, jumpXY))\n        return;\n    const jumpPosition = getPositionFromBoard(board, jumpXY);\n    if (Position.hasPiece(jumpPosition))\n        return;\n    return jumpPosition;\n}\n/**\n * Get board with checked where can I go positions\n */\nfunction getBoardWhereCanIGo(board, from) {\n    const positions = getPositionsWhereCanIGo(board, from);\n    return mapBoard(board, position => Position.setICanGoHere(positions, position));\n}\n/**\n * Takes a board and return white and black pieces.\n * Used to calculate score from a board.\n *\n * returns { white: [{x,y}], black: [{x,y}] }\n */\nfunction getPiecesFromBoard(board) {\n    const initialPieces = {\n        white: [],\n        black: []\n    };\n    return board.reduce((piecesRow, row) => {\n        return row.reduce((pieces, position) => {\n            if (Position.hasBlackPiece(position))\n                pieces.black = pieces.black.concat(position);\n            else if (Position.hasWhitePiece(position))\n                pieces.white = pieces.white.concat(position);\n            return pieces;\n        }, piecesRow);\n    }, initialPieces);\n}\nexport { _getCleanBoard, _getInitialBoard, _getNearPositions, defaultBoardSize, getInitialBoard, getBoardWithPieces, getBoardWhereCanIGo, getCleanBoard, getStartEndRow, getStartEndRows, getStartPieces, getEmptyNearPositions, getJumpPosition, getNearPositions, getNotEmptyNearPositions, getPiecesFromBoard, getPiecesWhereCanIGo, getPositionFromBoard, getPositionsFromBoard, getPositionsWhereCanIGo, mapBoard, printBoard, printUnicodeBoard, printXAndYBoard, whereCanIJump, hasPosition, hasPositionByBoardSize };\n//# sourceMappingURL=Board.js.map"]}