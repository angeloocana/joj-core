{"version":3,"sources":["../dist-esnext/Board.js"],"names":["Position","Positions","defaultBoardSize","x","y","hasPosition","board","position","length","mapBoard","func","map","col","p","getColorStartEndRow","boardEndRow","isBlack","startRow","endRow","getBoardConf","boardSize","size","white","black","defaultBoardConf","_getInitialBoard","memoize","boardConf","blackPieces","whitePieces","push","getInitialBoard","getPosition","e","Error","setPosition","setPieceOnBoard","setPiece","removePieceOnBoard","removePiece","getCleanBoard","getCleanPosition","getBoardSizeX","getBoardSizeY","getBoardSize","printBoard","printPosition","reduce","txtCol","txtRow","printBoardCurried","curry","printUnicodeBoard","printUnicodePosition","printXAndYBoard","printXAndYPosition","getPositionsWhereCanIGo","from","allNearPositions","getNearPositions","undefined","positions","orderedPositions","i","nearPosition","hasNoPiece","getYAsBlack","getToSearchOrder","jumpPosition","getJumpPosition","jumps","whereCanIJump","onlyEmpty","add","plusX","plusY","newPosition","toJumpPosition","hasPiece","jumpFrom","nearFilledPositions","forEach","nearFilledPosition","notContains","lastPosition","jumpingBlackPiece","getBoardWhereCanIGo","blackPiece","setICanGoHere"],"mappings":"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","file":"Board.js","sourcesContent":["import R from 'ramda';\nimport * as Position from './Position';\nimport * as Positions from './Positions';\nimport log from 'ptz-log';\n/**\n * Default 8x8 board size\n */\nconst defaultBoardSize = { x: 8, y: 8 };\n/**\n * Check if position exists on board\n */\nconst hasPosition = (board, position) => position\n    && position.x >= 0 && position.y >= 0\n    && board.length > position.y && board[position.y].length > position.x;\n/**\n * Map some function in all board positions and return a new board\n */\nconst mapBoard = (board, func) => board.map(col => col.map(p => func(p)));\nfunction getColorStartEndRow(boardEndRow, isBlack) {\n    return {\n        startRow: isBlack ? 0 : boardEndRow,\n        endRow: isBlack ? boardEndRow : 0\n    };\n}\nfunction getBoardConf(boardSize) {\n    const endRow = boardSize.y - 1;\n    return {\n        size: boardSize,\n        endRow,\n        white: getColorStartEndRow(endRow, false),\n        black: getColorStartEndRow(endRow, true)\n    };\n}\n/**\n * Default configuration for 8x8 board\n */\nconst defaultBoardConf = getBoardConf(defaultBoardSize);\n/**\n * Get cached initial board, using memoize from ramda\n *\n * The _getInitialBoard returns :Function Type,\n * that's why we created getInitialBoard witch returns :IGetInitialBoardResult\n * in order to reduce type errors.\n */\n// tslint:disable-next-line:variable-name\nconst _getInitialBoard = R.memoize((boardConf) => {\n    // Do NOT remove the log below. We use it to check if cache works and this code run once.\n    log('--> You MUST see this msg only once, otherwise memoize is not working <-- \\n _getInitialBoard for', boardConf);\n    const board = [], blackPieces = [], whitePieces = [];\n    for (let x = 0; x < boardConf.size.x; x++) {\n        for (let y = 0; y < boardConf.size.y; y++) {\n            if (!board[y])\n                board[y] = [];\n            const position = { x, y };\n            if (y === 0) {\n                position.isBlack = true;\n                blackPieces.push({ position });\n            }\n            if (y === boardConf.endRow) {\n                position.isBlack = false;\n                whitePieces.push({ position });\n            }\n            board[y][x] = position;\n        }\n    }\n    return {\n        board,\n        blackPieces,\n        whitePieces\n    };\n});\n/**\n * Get cached initial board, using memoize from ramda\n */\nfunction getInitialBoard(boardConf) {\n    return _getInitialBoard(boardConf);\n}\nfunction getPosition(board, position) {\n    try {\n        return board[position.y][position.x];\n    }\n    catch (e) {\n        throw new Error('Error getting position');\n    }\n}\nfunction setPosition(board, position) {\n    try {\n        board[position.y][position.x] = position;\n        return board;\n    }\n    catch (e) {\n        throw new Error('Error getting position');\n    }\n}\nconst setPieceOnBoard = (board, position, isBlack) => setPosition(board, Position.setPiece(isBlack, position));\nconst removePieceOnBoard = (board, position) => setPosition(board, Position.removePiece(position));\nconst getCleanBoard = (board) => mapBoard(board, Position.getCleanPosition);\n/**\n * Take a board: IPosition[][] an return the number of rows(X)\n */\nconst getBoardSizeX = (board) => board[0].length;\n/**\n * Take a board: IPosition[][] an return the number of rows(Y)\n */\nconst getBoardSizeY = (board) => board.length;\n/**\n * Take a board: IPosition[][] an return the number of columns and rows {x, y}\n */\nfunction getBoardSize(board) {\n    return {\n        x: getBoardSizeX(board),\n        y: getBoardSizeY(board)\n    };\n}\n/**\n * Takes a function to printPosition and print board.\n */\nfunction printBoard(printPosition, board) {\n    return board.reduce((txtCol, col) => {\n        return col.reduce((txtRow, position) => {\n            return txtRow + printPosition(position);\n        }, txtCol) + '\\n';\n    }, '');\n}\nconst printBoardCurried = R.curry(printBoard);\n/**\n * Get board in a nice format to print it on console\n */\nconst printUnicodeBoard = printBoardCurried(Position.printUnicodePosition);\n/**\n * Prints only X and Y positions of a board.\n */\nconst printXAndYBoard = printBoardCurried(Position.printXAndYPosition);\nfunction getPositionsWhereCanIGo(board, from, isBlack) {\n    if (!from)\n        return null;\n    const allNearPositions = getNearPositions(board, from, undefined);\n    const positions = [];\n    const orderedPositions = [];\n    for (let i = 0; i < allNearPositions.length; i++) {\n        const nearPosition = allNearPositions[i];\n        if (Position.hasNoPiece(nearPosition)) {\n            positions.push(nearPosition);\n            const y = Position.getYAsBlack(getBoardSizeY(board), nearPosition.y, isBlack);\n            if (!orderedPositions[y])\n                orderedPositions[y] = [];\n            orderedPositions[y][Position.getToSearchOrder(getBoardSize(board), nearPosition.x)] = nearPosition;\n        }\n        else {\n            const jumpPosition = getJumpPosition(board, from, nearPosition);\n            if (jumpPosition) {\n                jumpPosition.jumps = 1;\n                positions.push(jumpPosition);\n                const y = Position.getYAsBlack(getBoardSizeY(board), jumpPosition.y, isBlack);\n                if (!orderedPositions[y])\n                    orderedPositions[y] = [];\n                orderedPositions[y][Position.getToSearchOrder(getBoardSize(board), jumpPosition.x)] = jumpPosition;\n                whereCanIJump(board, jumpPosition, positions, orderedPositions, isBlack);\n            }\n        }\n    }\n    return {\n        positions,\n        orderedPositions\n    };\n}\nfunction getNearPositions(board, position, onlyEmpty) {\n    const positions = [];\n    function add(plusX, plusY) {\n        var newPosition = {\n            x: position.x + plusX,\n            y: position.y + plusY\n        };\n        if (!hasPosition(board, newPosition))\n            return;\n        newPosition = getPosition(board, newPosition);\n        if (typeof onlyEmpty !== 'undefined') {\n            if (onlyEmpty === Position.hasNoPiece(newPosition))\n                positions.push(newPosition);\n        }\n        else\n            positions.push(newPosition);\n    }\n    add(-1, -1);\n    add(0, -1);\n    add(+1, -1);\n    add(-1, 0);\n    add(+1, 0);\n    add(-1, +1);\n    add(0, +1);\n    add(+1, +1);\n    return positions;\n}\nfunction getJumpPosition(board, from, toJumpPosition) {\n    var jumpPosition = { x: 0, y: 0 };\n    if (from.x < toJumpPosition.x)\n        jumpPosition.x = toJumpPosition.x + 1;\n    else if (from.x > toJumpPosition.x)\n        jumpPosition.x = toJumpPosition.x - 1;\n    else\n        jumpPosition.x = toJumpPosition.x;\n    if (from.y < toJumpPosition.y)\n        jumpPosition.y = toJumpPosition.y + 1;\n    else if (from.y > toJumpPosition.y)\n        jumpPosition.y = toJumpPosition.y - 1;\n    else\n        jumpPosition.y = toJumpPosition.y;\n    if (!hasPosition(board, jumpPosition)) {\n        return;\n    }\n    jumpPosition = getPosition(board, jumpPosition);\n    if (Position.hasPiece(jumpPosition)) {\n        return;\n    }\n    return jumpPosition;\n}\n// tslint:disable-next-line:max-line-length\nfunction whereCanIJump(board, jumpFrom, positions, orderedPositions, isBlack) {\n    const nearFilledPositions = getNearPositions(board, jumpFrom, false);\n    nearFilledPositions.forEach(nearFilledPosition => {\n        const jumpPosition = getJumpPosition(board, jumpFrom, nearFilledPosition);\n        if (jumpPosition) {\n            if (Positions.notContains(positions, jumpPosition)) {\n                jumpPosition.lastPosition = jumpFrom;\n                jumpPosition.jumpingBlackPiece = nearFilledPosition.isBlack;\n                jumpPosition.jumps = jumpFrom.jumps ? jumpFrom.jumps++ : 2;\n                positions.push(jumpPosition);\n                const y = Position.getYAsBlack(getBoardSizeY(board), jumpPosition.y, isBlack);\n                if (!orderedPositions[y])\n                    orderedPositions[y] = [];\n                orderedPositions[y][Position.getToSearchOrder(getBoardSize(board), jumpPosition.x)] = jumpPosition;\n                whereCanIJump(board, jumpPosition, positions, orderedPositions, isBlack);\n            }\n        }\n    });\n}\nfunction getBoardWhereCanIGo(board, from, blackPiece) {\n    const { positions } = getPositionsWhereCanIGo(board, from, blackPiece);\n    return mapBoard(board, position => Position.setICanGoHere(positions, position));\n}\nexport { defaultBoardSize, defaultBoardConf, getCleanBoard, getInitialBoard, getBoardConf, getBoardWhereCanIGo, getColorStartEndRow, getJumpPosition, getNearPositions, getPosition, getPositionsWhereCanIGo, printBoard, printBoardCurried, printUnicodeBoard, printXAndYBoard, whereCanIJump, setPieceOnBoard, setPosition, removePieceOnBoard, hasPosition };\n//# sourceMappingURL=Board.js.map"]}