{"version":3,"sources":["../dist-esnext/Board.js"],"names":["Position","Positions","defaultBoardSize","x","y","hasPositionByBoardSize","boardSize","position","hasPosition","board","getBoardSize","mapBoard","func","map","col","p","getColorStartEndRow","boardEndRow","isBlack","startRow","endRow","getBoardConf","size","white","black","defaultBoardConf","_getInitialBoard","memoize","boardConf","blackPieces","whitePieces","push","getInitialBoard","getPosition","e","Error","setPosition","setPieceOnBoard","setPiece","removePieceOnBoard","removePiece","getCleanBoard","getCleanPosition","getBoardSizeX","length","getBoardSizeY","printBoard","printPosition","reduce","txtCol","txtRow","printBoardCurried","curry","printUnicodeBoard","printUnicodePosition","printXAndYBoard","printXAndYPosition","getPositionsWhereCanIGo","from","allNearPositions","getNearPositions","positions","orderedPositions","i","nearPosition","hasNoPiece","getYAsBlack","getToSearchOrder","jumpPosition","getJumpPosition","jumps","whereCanIJump","getAllNearPositions","toAdd","_getNearPositions","filter","getXAndY","getEmptyNearPositions","getNotEmptyNearPositions","hasPiece","toJumpPosition","jumpFrom","nearFilledPositions","forEach","nearFilledPosition","notContains","lastPosition","jumpingBlackPiece","getBoardWhereCanIGo","blackPiece","setICanGoHere"],"mappings":"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","file":"Board.js","sourcesContent":["import R from 'ramda';\nimport * as Position from './Position';\nimport * as Positions from './Positions';\nimport log from 'ptz-log';\n/**\n * Default 8x8 board size\n */\nconst defaultBoardSize = { x: 8, y: 8 };\n/**\n * Checks if position exists in this board size\n */\nconst hasPositionByBoardSize = (boardSize, position) => position\n    && position.x >= 0 && position.y >= 0\n    && boardSize.y > position.y && boardSize.x > position.x;\n/**\n * Check if position exists on board\n */\nconst hasPosition = (board, position) => hasPositionByBoardSize(getBoardSize(board), position);\n/**\n * Map some function in all board positions and return a new board\n */\nconst mapBoard = (board, func) => board.map(col => col.map(p => func(p)));\nfunction getColorStartEndRow(boardEndRow, isBlack) {\n    return {\n        startRow: isBlack ? 0 : boardEndRow,\n        endRow: isBlack ? boardEndRow : 0\n    };\n}\nfunction getBoardConf(boardSize) {\n    const endRow = boardSize.y - 1;\n    return {\n        size: boardSize,\n        endRow,\n        white: getColorStartEndRow(endRow, false),\n        black: getColorStartEndRow(endRow, true)\n    };\n}\n/**\n * Default configuration for 8x8 board\n */\nconst defaultBoardConf = getBoardConf(defaultBoardSize);\n/**\n * Get cached initial board, using memoize from ramda\n *\n * The _getInitialBoard returns :Function Type,\n * that's why we created getInitialBoard witch returns :IGetInitialBoardResult\n * in order to reduce type errors.\n */\n// tslint:disable-next-line:variable-name\nconst _getInitialBoard = R.memoize((boardConf) => {\n    // Do NOT remove the log below. We use it to check if cache works and this code run once.\n    log('--> You MUST see this msg only once, otherwise memoize is not working <-- \\n _getInitialBoard for', boardConf);\n    const board = [], blackPieces = [], whitePieces = [];\n    for (let x = 0; x < boardConf.size.x; x++) {\n        for (let y = 0; y < boardConf.size.y; y++) {\n            if (!board[y])\n                board[y] = [];\n            const position = { x, y };\n            if (y === 0) {\n                position.isBlack = true;\n                blackPieces.push({ position });\n            }\n            if (y === boardConf.endRow) {\n                position.isBlack = false;\n                whitePieces.push({ position });\n            }\n            board[y][x] = position;\n        }\n    }\n    return {\n        board,\n        blackPieces,\n        whitePieces\n    };\n});\n/**\n * Get cached initial board, using memoize from ramda\n */\nfunction getInitialBoard(boardConf) {\n    return _getInitialBoard(boardConf);\n}\nfunction getPosition(board, position) {\n    try {\n        return board[position.y][position.x];\n    }\n    catch (e) {\n        throw new Error('Error getting position');\n    }\n}\nfunction setPosition(board, position) {\n    try {\n        board[position.y][position.x] = position;\n        return board;\n    }\n    catch (e) {\n        throw new Error('Error getting position');\n    }\n}\nconst setPieceOnBoard = (board, position, isBlack) => setPosition(board, Position.setPiece(isBlack, position));\nconst removePieceOnBoard = (board, position) => setPosition(board, Position.removePiece(position));\nconst getCleanBoard = (board) => mapBoard(board, Position.getCleanPosition);\n/**\n * Take a board: IPosition[][] an return the number of rows(X)\n */\nconst getBoardSizeX = (board) => board[0].length;\n/**\n * Take a board: IPosition[][] an return the number of rows(Y)\n */\nconst getBoardSizeY = (board) => board.length;\n/**\n * Take a board: IPosition[][] an return the number of columns and rows {x, y}\n */\nfunction getBoardSize(board) {\n    return {\n        x: getBoardSizeX(board),\n        y: getBoardSizeY(board)\n    };\n}\n/**\n * Takes a function to printPosition and print board.\n */\nfunction printBoard(printPosition, board) {\n    return board.reduce((txtCol, col) => {\n        return col.reduce((txtRow, position) => {\n            return txtRow + printPosition(position);\n        }, txtCol) + '\\n';\n    }, '');\n}\nconst printBoardCurried = R.curry(printBoard);\n/**\n * Get board in a nice format to print it on console\n */\nconst printUnicodeBoard = printBoardCurried(Position.printUnicodePosition);\n/**\n * Prints only X and Y positions of a board.\n */\nconst printXAndYBoard = printBoardCurried(Position.printXAndYPosition);\nfunction getPositionsWhereCanIGo(board, from, isBlack) {\n    if (!from)\n        return null;\n    const allNearPositions = getNearPositions(board, from);\n    const positions = [];\n    const orderedPositions = [];\n    for (let i = 0; i < allNearPositions.length; i++) {\n        const nearPosition = allNearPositions[i];\n        if (Position.hasNoPiece(nearPosition)) {\n            positions.push(nearPosition);\n            const y = Position.getYAsBlack(getBoardSizeY(board), nearPosition.y, isBlack);\n            if (!orderedPositions[y])\n                orderedPositions[y] = [];\n            orderedPositions[y][Position.getToSearchOrder(getBoardSize(board), nearPosition.x)] = nearPosition;\n        }\n        else {\n            const jumpPosition = getJumpPosition(board, from, nearPosition);\n            if (jumpPosition) {\n                jumpPosition.jumps = 1;\n                positions.push(jumpPosition);\n                const y = Position.getYAsBlack(getBoardSizeY(board), jumpPosition.y, isBlack);\n                if (!orderedPositions[y])\n                    orderedPositions[y] = [];\n                orderedPositions[y][Position.getToSearchOrder(getBoardSize(board), jumpPosition.x)] = jumpPosition;\n                whereCanIJump(board, jumpPosition, positions, orderedPositions, isBlack);\n            }\n        }\n    }\n    return {\n        positions,\n        orderedPositions\n    };\n}\n/**\n * Get all valid and invalid near positions.\n */\nfunction getAllNearPositions(position) {\n    return [\n        [-1, -1],\n        [0, -1],\n        [1, -1],\n        [-1, 0],\n        [1, 0],\n        [-1, 1],\n        [0, 1],\n        [1, 1]\n    ].map(toAdd => {\n        return {\n            x: position.x + toAdd[0],\n            y: position.y + toAdd[1]\n        };\n    });\n}\n/**\n * Get near positions and CACHES it for each boardSize\n */\nconst _getNearPositions = R.memoize((boardSize, position) => getAllNearPositions(position)\n    .filter(p => hasPositionByBoardSize(boardSize, p)));\n/**\n * Get near positions\n */\nfunction getNearPositions(board, position) {\n    return _getNearPositions(getBoardSize(board), Position.getXAndY(position))\n        .map(p => getPosition(board, p));\n}\n/**\n * Get empty near positions\n */\nconst getEmptyNearPositions = (board, position) => getNearPositions(board, position)\n    .filter(p => Position.hasNoPiece(p));\n/**\n * Get not empty near positions\n */\nconst getNotEmptyNearPositions = (board, position) => getNearPositions(board, position)\n    .filter(p => Position.hasPiece(p));\nfunction getJumpPosition(board, from, toJumpPosition) {\n    var jumpPosition = { x: 0, y: 0 };\n    if (from.x < toJumpPosition.x)\n        jumpPosition.x = toJumpPosition.x + 1;\n    else if (from.x > toJumpPosition.x)\n        jumpPosition.x = toJumpPosition.x - 1;\n    else\n        jumpPosition.x = toJumpPosition.x;\n    if (from.y < toJumpPosition.y)\n        jumpPosition.y = toJumpPosition.y + 1;\n    else if (from.y > toJumpPosition.y)\n        jumpPosition.y = toJumpPosition.y - 1;\n    else\n        jumpPosition.y = toJumpPosition.y;\n    if (!hasPosition(board, jumpPosition)) {\n        return;\n    }\n    jumpPosition = getPosition(board, jumpPosition);\n    if (Position.hasPiece(jumpPosition)) {\n        return;\n    }\n    return jumpPosition;\n}\n// tslint:disable-next-line:max-line-length\nfunction whereCanIJump(board, jumpFrom, positions, orderedPositions, isBlack) {\n    const nearFilledPositions = getNotEmptyNearPositions(board, jumpFrom);\n    nearFilledPositions.forEach(nearFilledPosition => {\n        const jumpPosition = getJumpPosition(board, jumpFrom, nearFilledPosition);\n        if (jumpPosition) {\n            if (Positions.notContains(positions, jumpPosition)) {\n                jumpPosition.lastPosition = jumpFrom;\n                jumpPosition.jumpingBlackPiece = nearFilledPosition.isBlack;\n                jumpPosition.jumps = jumpFrom.jumps ? jumpFrom.jumps++ : 2;\n                positions.push(jumpPosition);\n                const y = Position.getYAsBlack(getBoardSizeY(board), jumpPosition.y, isBlack);\n                if (!orderedPositions[y])\n                    orderedPositions[y] = [];\n                orderedPositions[y][Position.getToSearchOrder(getBoardSize(board), jumpPosition.x)] = jumpPosition;\n                whereCanIJump(board, jumpPosition, positions, orderedPositions, isBlack);\n            }\n        }\n    });\n}\n/**\n * Get board with checked where can I go positions\n */\nfunction getBoardWhereCanIGo(board, from, blackPiece) {\n    const { positions } = getPositionsWhereCanIGo(board, from, blackPiece);\n    return mapBoard(board, position => Position.setICanGoHere(positions, position));\n}\nexport { _getInitialBoard, _getNearPositions, defaultBoardSize, defaultBoardConf, getCleanBoard, getInitialBoard, getBoardConf, getBoardWhereCanIGo, getColorStartEndRow, getEmptyNearPositions, getJumpPosition, getNearPositions, getNotEmptyNearPositions, getPosition, getPositionsWhereCanIGo, printBoard, printBoardCurried, printUnicodeBoard, printXAndYBoard, whereCanIJump, setPieceOnBoard, setPosition, removePieceOnBoard, hasPosition, hasPositionByBoardSize };\n//# sourceMappingURL=Board.js.map"]}