{"version":3,"sources":["../dist-esnext/Game.test.js"],"names":["assert","TestData","describe","it","firstMove","from","x","y","to","moveFrom","game","getGameAfterMove","initialGame","ok","isMyTurn","notOk","score","ended","equal","getPlayerTurn","players","white","black","createGame","pieces","getTurnPieces","expectedPieces","startWhitePiecesExpected","deepEqual","startBlackPiecesExpected"],"mappings":"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","file":"Game.test.js","sourcesContent":["import * as assert from 'ptz-assert';\nimport * as TestData from './__testdata__/index.data.test';\nimport { Game, Move } from './index';\ndescribe('Game', () => {\n    describe('create', () => {\n        it('creates a new game');\n    });\n    describe('needToValidateMovements', () => {\n        it('when null should validate');\n        it('when undefined should validate');\n        it('when true should validate');\n        it('when false should NOT validate');\n    });\n    describe('isMyTurn', () => {\n        it('returns true for black piece and black turn', () => {\n            const firstMove = { from: { x: 5, y: 7 }, to: { x: 5, y: 6 } };\n            const moveFrom = { x: 5, y: 0 };\n            const game = Move.getGameAfterMove(TestData.initialGame, firstMove);\n            assert.ok(Game.isMyTurn(game, moveFrom));\n        });\n        it('returns true for white piece and white turn', () => {\n            const from = { x: 5, y: 7 };\n            assert.ok(Game.isMyTurn(TestData.initialGame, from));\n        });\n        it('returns false for white piece and black turn', () => {\n            const firstMove = { from: { x: 5, y: 7 }, to: { x: 5, y: 6 } };\n            const game = Move.getGameAfterMove(TestData.initialGame, firstMove);\n            const from = { x: 7, y: 7 };\n            assert.notOk(Game.isMyTurn(game, from));\n        });\n        it('returns false for black piece and white turn', () => {\n            const from = { x: 5, y: 0 };\n            assert.notOk(Game.isMyTurn(TestData.initialGame, from));\n        });\n        it('returns false for ended game', () => {\n            const firstMove = { from: { x: 5, y: 7 }, to: { x: 5, y: 6 } };\n            const game = Move.getGameAfterMove(TestData.initialGame, firstMove);\n            const from = { x: 5, y: 0 };\n            // $Fix\n            // I dont know if it is the best way\n            // Are getGameAfterMove supposed to calculate if game is ended???\n            game.score.ended = true;\n            assert.notOk(Game.isMyTurn(game, from));\n        });\n    });\n    describe('getPlayerTurn', () => {\n        it('return white player when white turn', () => {\n            assert.equal(Game.getPlayerTurn(TestData.initialGame), TestData.initialGame.players.white);\n        });\n        it('return black player when black turn', () => {\n            const firstMove = { from: { x: 5, y: 7 }, to: { x: 5, y: 6 } };\n            const game = Move.getGameAfterMove(TestData.initialGame, firstMove);\n            assert.equal(Game.getPlayerTurn(game), game.players.black);\n        });\n    });\n    describe('getTurnPieces', () => {\n        it('return white pieces', () => {\n            const game = Game.createGame();\n            const pieces = Game.getTurnPieces(game);\n            const expectedPieces = TestData.startWhitePiecesExpected;\n            assert.deepEqual(pieces, expectedPieces);\n        });\n        it('return black pieces', () => {\n            const game = Move.getGameAfterMove(Game.createGame(), { from: { x: 0, y: 7 }, to: { x: 0, y: 6 } });\n            const pieces = Game.getTurnPieces(game);\n            const expectedPieces = TestData.startBlackPiecesExpected;\n            assert.deepEqual(pieces, expectedPieces);\n        });\n    });\n});\n//# sourceMappingURL=Game.test.js.map"]}