{"version":3,"sources":["../dist-esnext/Move.js"],"names":["Board","Game","Position","Score","getBackMove","move","from","to","getMoveXAndY","getXAndY","canMove","game","isMyTurn","positionsWhereCanIGo","getPositionsWhereCanIGo","board","some","hasSameXY","position","canNotMove","compose","not","getBoardAfterMove","getPosition","mapBoard","x","p","y","isBlack","lastMove","hasPiece","containsXY","jumps","lastMoveJump","getGameAfterMove","backMove","players","score","getScore","moves","concat","getGameBeforeLastMove","Object","assign","pop","getPlayerTurn","isAi","getMoveFromArray","getPositionFromArray","getMovesFromArray","map","getGameAfterMoves","reduce","lastGame","getAllowedMovesFromArray","head","tail","getAllowedMovesFromArrays","arrMoves","a"],"mappings":"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","file":"Move.js","sourcesContent":["import R from 'ramda';\nimport * as Board from './Board';\nimport * as Game from './Game';\nimport * as Position from './Position';\nimport * as Score from './Score';\n/**\n * Returns reverse move: from = to, to = from\n */\nfunction getBackMove(move) {\n    return {\n        from: move.to,\n        to: move.from\n    };\n}\n/**\n * Takes a move and returns it with clean positions {from: {x,y}, to: {x,y}}.\n */\nfunction getMoveXAndY(move) {\n    return {\n        from: Position.getXAndY(move.from),\n        to: Position.getXAndY(move.to)\n    };\n}\n/**\n * Takes game and move then:\n *  - Checks if it is my turn to play otherwise returns false.\n *  - Get positions where can i go.\n *  - Returns true if move.to is in the positions where can i go.\n */\nfunction canMove(game, move) {\n    if (!Game.isMyTurn(game, move.from))\n        return false;\n    const positionsWhereCanIGo = Board.getPositionsWhereCanIGo(game.board, move.from);\n    return positionsWhereCanIGo.some(position => Position.hasSameXY(position, move.to));\n}\n/**\n * Can not move\n */\nconst canNotMove = R.compose(R.not, canMove);\n/**\n * Get board after move, return a new board with:\n *  - From: Remove piece and add .lastMove: true\n *  - To: Set piece from move.from and add .lastMove: true\n *  - Jumps: Create jump breadcrumb by setting .lastMoveJump: true\n */\nfunction getBoardAfterMove(board, move) {\n    const from = Board.getPosition(board, move.from);\n    return Board.mapBoard(board, p => {\n        const { x, y, isBlack } = p;\n        if (Position.hasSameXY(from, p))\n            return { x, y, lastMove: true };\n        if (Position.hasSameXY(move.to, p))\n            return { x, y, isBlack: from.isBlack, lastMove: true };\n        if (Position.hasPiece(p))\n            return { x, y, isBlack };\n        if (Position.containsXY(move.to.jumps, p))\n            return { x, y, lastMoveJump: true };\n        return { x, y };\n    });\n}\n/**\n * Takes game and move then returns new game after move.\n *\n * Updates:\n *  - .board (It cleans board, set new positions and move breadcrumb)\n *  - .score\n *  - .moves (add new move if valid and it is not backMove)\n */\nfunction getGameAfterMove(game, move, backMove = false) {\n    if (!backMove && canNotMove(game, move))\n        return game;\n    const board = getBoardAfterMove(game.board, move);\n    return {\n        players: game.players,\n        board,\n        score: Score.getScore(game.board),\n        moves: backMove ? game.moves : game.moves.concat(getMoveXAndY(move))\n    };\n}\n/**\n * Get game before last move,\n * if playing vs Ai rollback Ai move too.\n */\nfunction getGameBeforeLastMove(game) {\n    // $Fix I do NOT know if it is the best way to make game immutable.\n    game = Object.assign({}, game);\n    let lastMove = game.moves.pop();\n    if (lastMove)\n        game = getGameAfterMove(game, getBackMove(lastMove), true);\n    if (Game.getPlayerTurn(game).isAi) {\n        lastMove = game.moves.pop();\n        if (lastMove) {\n            game = getGameAfterMove(game, getBackMove(lastMove), true);\n        }\n    }\n    return game;\n}\n/**\n * Get IMove from an array like\n * [[fromX,fromY], [toX, toY]]\n *\n * const move = [[5, 7], [5, 6]];\n */\nfunction getMoveFromArray(move) {\n    return {\n        from: Position.getPositionFromArray(move[0]),\n        to: Position.getPositionFromArray(move[1])\n    };\n}\n/**\n * Get IMove[] from an array like\n * [[fromX,fromY], [toX, toY]]\n *\n * const moves = [\n *      [[5, 7], [5, 6]],\n *      [[2, 0], [2, 1]],\n *      [[7, 7], [5, 5]]\n * ];\n */\nconst getMovesFromArray = (moves) => moves.map(move => getMoveFromArray(move));\n/**\n * Get game after n moves.\n */\nconst getGameAfterMoves = (game, moves) => moves.reduce((lastGame, move) => {\n    return getGameAfterMove(lastGame, move);\n}, game);\n/**\n * Takes an array like:\n *\n * [[fromX, fromY], ...[toX, toY]]\n *\n * and return IMove[]\n */\nfunction getAllowedMovesFromArray(moves) {\n    const from = Position.getPositionFromArray(R.head(moves));\n    return R.tail(moves).map(to => {\n        return { from, to: Position.getPositionFromArray(to) };\n    });\n}\n/**\n * Takes an array like:\n *\n * [\n *\n *   [[fromX, fromY], ...[toX, toY]],\n *\n *   [[fromX, fromY], ...[toX, toY]]\n *\n * ]\n *\n * and return IMove[].\n *\n * Used to create smaller test data.\n */\nfunction getAllowedMovesFromArrays(arrMoves) {\n    return arrMoves.reduce((moves, a) => {\n        return moves.concat(getAllowedMovesFromArray(a));\n    }, []);\n}\nexport { canMove, getAllowedMovesFromArray, getAllowedMovesFromArrays, getBackMove, getBoardAfterMove, getGameAfterMove, getGameAfterMoves, getGameBeforeLastMove, getMoveFromArray, getMovesFromArray, getMoveXAndY };\n//# sourceMappingURL=Move.js.map"]}