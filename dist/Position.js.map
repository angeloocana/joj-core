{"version":3,"sources":["../dist-esnext/Position.js"],"names":["getPositionFromArray","position","x","y","getPositionWhereCanIGoFromArray","isBlack","positions","head","whereCanIGo","tail","map","getPositionsWhereCanIGoFromArray","p","getPositionFromPositions","find","hasSameXY","getXAndY","hasBlackPiece","hasWhitePiece","hasPiece","anyPass","hasNoPiece","compose","not","setPiece","curry","Object","assign","setPieceToBlack","setPieceToWhite","setICanGoHere","positionsWhereCanIGo","iCanGoHere","containsXY","p1","p2","isBackGroundBlack","getToSearchOrder","boardSize","getY0Start","boardSizeY","getY0End","printXAndYPosition","printUnicodeBackgroundBlack","printUnicodeBackgroundWhite","printUnicodePosition","some","notContainsXY","getOrderedPositions","getYAs","reduce","ordered","concat","getOrderedPositionsY0Start","getOrderedPositionsY0End"],"mappings":"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","file":"Position.js","sourcesContent":["import R from 'ramda';\n/**\n * Get [x,y] and returns {x, y}\n *\n * const position = [5, 7];\n */\nfunction getPositionFromArray(position) {\n    return {\n        x: position[0],\n        y: position[1]\n    };\n}\n/**\n * Gets an array like [[0, 7], [0, 6], [1, 6]],\n * where [[positionX, positionY], ...[[whereCanIGoX, whereCanIGoY]]]\n * then returns IPiece.\n *\n * Used to create clean test data.\n */\nfunction getPositionWhereCanIGoFromArray(isBlack, positions) {\n    const { x, y } = getPositionFromArray(R.head(positions));\n    return {\n        x, y, isBlack,\n        whereCanIGo: R.tail(positions).map(getPositionFromArray)\n    };\n}\n/**\n * Gets an array like [[[0, 7], [0, 6], [1, 6]]],\n * where [[[positionX, positionY], ...[[whereCanIGoX, whereCanIGoY]]]]\n * then returns IPiece[].\n *\n * Used to create clean test data.\n */\nconst getPositionsWhereCanIGoFromArray = (isBlack, positions) => positions.map(p => getPositionWhereCanIGoFromArray(isBlack, p));\n/**\n * Returns a position from an array of positions with equal X an Y.\n */\nconst getPositionFromPositions = (positions, position) => positions.find(p => hasSameXY(p, position));\n/**\n * Takes a position and return only {x, y}.\n */\nfunction getXAndY({ x, y }) {\n    return { x, y };\n}\n/**\n * .isBlack equal true.\n */\nconst hasBlackPiece = (p) => p.isBlack === true;\n/**\n * .isBlack equal false.\n */\nconst hasWhitePiece = (p) => p.isBlack === false;\n/**\n * .isBlack is true or false.\n */\nconst hasPiece = R.anyPass([hasBlackPiece, hasWhitePiece]);\n/**\n * .isBlack is undefined or null.\n */\nconst hasNoPiece = R.compose(R.not, hasPiece);\nconst setPiece = R.curry((isBlack, position) => Object.assign({}, position, { isBlack }));\nconst setPieceToBlack = setPiece(true);\nconst setPieceToWhite = setPiece(false);\n/**\n * Takes a position and return a new position with iCanGoHere checked.\n */\nconst setICanGoHere = (positionsWhereCanIGo, position) => Object.assign({\n    iCanGoHere: containsXY(positionsWhereCanIGo, position)\n}, position);\n/**\n * Takes 2 positions and return true when same x and y.\n */\nconst hasSameXY = (p1, p2) => p1.x === p2.x && p1.y === p2.y;\n/**\n * Get the board background color of a position.\n */\nconst isBackGroundBlack = (x, y) => (x % 2 === 0) ? (y % 2 === 0) : (y % 2 !== 0);\n/**\n * Returns the index to store the position in orderedPositions.\n *\n * The order to search is 0, 7, 1, 6, 2, 5, 3, 1.\n *\n * The goal is to fill the corners first.\n */\nconst getToSearchOrder = R.curry((boardSize, x) => {\n    switch (x) {\n        case 0:\n            return 0;\n        case 1:\n            return 2;\n        case 2:\n            return 4;\n        case 3:\n            return 6;\n        case 4:\n            return 7;\n        case 5:\n            return 5;\n        case 6:\n            return 3;\n        case 7:\n            return 1;\n        default:\n            return null;\n    }\n});\n/**\n * It Inverts white Y position.\n *\n * For 8x8 board Get Y starting from 0 and ending on 7 for both black and white positions.\n */\nconst getY0Start = R.curry((boardSizeY, y, isBlack) => isBlack ? y : (boardSizeY - 1) - y);\n/**\n * It Inverts black Y position.\n *\n * For 8x8 board Get Y starting from 7 and ending on 0 for both black and white positions.\n */\nconst getY0End = R.curry((boardSizeY, y, isBlack) => isBlack ? (boardSizeY - 1) - y : y);\nconst printXAndYPosition = (p) => ` ${p.x},${p.y} |`;\n/**\n * Print unicode position for black background.\n * @param p position\n */\nconst printUnicodeBackgroundBlack = (p) => {\n    if (hasWhitePiece(p))\n        return '\\u{25CF}';\n    else if (hasBlackPiece(p))\n        return '\\u{25CB}';\n    else\n        return ' ';\n};\n/**\n * Print unicode position for white background.\n * @param p position\n */\nconst printUnicodeBackgroundWhite = (p) => {\n    if (hasWhitePiece(p))\n        return '\\u{25D9}';\n    else if (hasBlackPiece(p))\n        return '\\u{25D8}';\n    else\n        return '\\u{2588}';\n};\n/**\n * Print unicode position to print the board in console.\n * @param p position\n */\nconst printUnicodePosition = (p) => isBackGroundBlack(p.x, p.y)\n    ? printUnicodeBackgroundBlack(p)\n    : printUnicodeBackgroundWhite(p);\n/**\n * Checks if an array of positions contains a position.\n */\nconst containsXY = (positions, position) => positions ? positions.some(p => hasSameXY(p, position)) : false;\n/**\n * Checks if an array of positions NOT contains a position.\n */\nconst notContainsXY = R.compose(R.not, containsXY);\n/**\n * Get ordered positions IPosition[Y][positions]\n */\nconst getOrderedPositions = R.curry((getYAs, boardSizeY, isBlack, positions) => positions.reduce((ordered, position) => {\n    const y = getYAs(boardSizeY, position.y, isBlack);\n    ordered[y] = (ordered[y] || []).concat(position);\n    return ordered;\n}, []));\n/**\n * Get ordered positions as black IPosition[Y = 0 -> endRow][positions]\n */\nconst getOrderedPositionsY0Start = R.curry(getOrderedPositions(getY0Start));\n/**\n * Get ordered positions as white IPosition[Y = endRow -> 0][positions]\n */\nconst getOrderedPositionsY0End = R.curry(getOrderedPositions(getY0End));\nexport { containsXY, isBackGroundBlack, getPositionFromArray, getPositionFromPositions, getPositionWhereCanIGoFromArray, getPositionsWhereCanIGoFromArray, getToSearchOrder, getOrderedPositions, getOrderedPositionsY0Start, getOrderedPositionsY0End, getXAndY, getY0Start, getY0End, hasSameXY, hasBlackPiece, hasPiece, hasNoPiece, hasWhitePiece, notContainsXY, printXAndYPosition, printUnicodePosition, setICanGoHere, setPiece, setPieceToBlack, setPieceToWhite };\n//# sourceMappingURL=Position.js.map"]}