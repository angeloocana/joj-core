{"version":3,"sources":["../dist-esnext/Position.js"],"names":["getPositionFromArray","position","x","y","getPositionWhereCanIGoFromArray","isBlack","positions","head","whereCanIGo","tail","map","getPositionsWhereCanIGoFromArray","p","getPositionFromPositions","find","hasSameXY","getXAndY","hasBlackPiece","hasWhitePiece","hasPiece","anyPass","hasNoPiece","compose","not","setPiece","curry","Object","assign","setPieceToBlack","setPieceToWhite","setICanGoHere","positionsWhereCanIGo","iCanGoHere","containsXY","p1","p2","isBackGroundBlack","getToSearchOrder","boardSize","getY0Start","boardSizeY","getY0End","getY0EndCurried","printXAndYPosition","printUnicodePosition","some","notContainsXY","getOrderedPositions","getYAs","reduce","ordered","concat","getOrderedPositionsCurried","getOrderedPositionsY0Start","getOrderedPositionsY0StartCurried","getOrderedPositionsY0End","getOrderedPositionsY0EndCurried"],"mappings":"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","file":"Position.js","sourcesContent":["import R from 'ramda';\n/**\n * Get [x,y] and returns {x, y}\n *\n * const position = [5, 7];\n */\nfunction getPositionFromArray(position) {\n    return {\n        x: position[0],\n        y: position[1]\n    };\n}\n/**\n * Gets an array like [[0, 7], [0, 6], [1, 6]],\n * where [[positionX, positionY], ...[[whereCanIGoX, whereCanIGoY]]]\n * then returns IPiece.\n *\n * Used to create clean test data.\n */\nfunction getPositionWhereCanIGoFromArray(isBlack, positions) {\n    const { x, y } = getPositionFromArray(R.head(positions));\n    return {\n        x, y, isBlack,\n        whereCanIGo: R.tail(positions).map(getPositionFromArray)\n    };\n}\n/**\n * Gets an array like [[[0, 7], [0, 6], [1, 6]]],\n * where [[[positionX, positionY], ...[[whereCanIGoX, whereCanIGoY]]]]\n * then returns IPiece[].\n *\n * Used to create clean test data.\n */\nconst getPositionsWhereCanIGoFromArray = (isBlack, positions) => positions.map(p => getPositionWhereCanIGoFromArray(isBlack, p));\n/**\n * Returns a position from an array of positions with equal X an Y.\n */\nconst getPositionFromPositions = (positions, position) => positions.find(p => hasSameXY(p, position));\n/**\n * Takes a position and return only {x, y}.\n */\nfunction getXAndY({ x, y }) {\n    return { x, y };\n}\n/**\n * .isBlack equal true.\n */\nconst hasBlackPiece = (p) => p.isBlack === true;\n/**\n * .isBlack equal false.\n */\nconst hasWhitePiece = (p) => p.isBlack === false;\n/**\n * .isBlack is true or false.\n */\nconst hasPiece = R.anyPass([hasBlackPiece, hasWhitePiece]);\n/**\n * .isBlack is undefined or null.\n */\nconst hasNoPiece = R.compose(R.not, hasPiece);\nconst setPiece = R.curry((isBlack, position) => Object.assign({}, position, { isBlack }));\nconst setPieceToBlack = setPiece(true);\nconst setPieceToWhite = setPiece(false);\n/**\n * Takes a position and return a new position with iCanGoHere checked.\n */\nconst setICanGoHere = (positionsWhereCanIGo, position) => Object.assign({\n    iCanGoHere: containsXY(positionsWhereCanIGo, position)\n}, position);\n/**\n * Takes 2 positions and return true when same x and y.\n */\nconst hasSameXY = (p1, p2) => p1.x === p2.x && p1.y === p2.y;\n/**\n * Get the board background color of a position.\n */\nconst isBackGroundBlack = (x, y) => (x % 2 === 0) ? (y % 2 === 0) : (y % 2 !== 0);\n/**\n * Returns the index to store the position in orderedPositions.\n *\n * The order to search is 0, 7, 1, 6, 2, 5, 3, 1.\n *\n * The goal is to fill the corners first.\n */\nconst getToSearchOrder = R.curry((boardSize, x) => {\n    switch (x) {\n        case 0:\n            return 0;\n        case 1:\n            return 2;\n        case 2:\n            return 4;\n        case 3:\n            return 6;\n        case 4:\n            return 7;\n        case 5:\n            return 5;\n        case 6:\n            return 3;\n        case 7:\n            return 1;\n        default:\n            return null;\n    }\n});\n/**\n * It Inverts white Y position.\n *\n * For 8x8 board Get Y starting from 0 and ending on 7 for both black and white positions.\n */\nconst getY0Start = R.curry((boardSizeY, y, isBlack) => isBlack ? y : (boardSizeY - 1) - y);\n/**\n * It Inverts black Y position.\n *\n * For 8x8 board Get Y starting from 7 and ending on 0 for both black and white positions.\n */\nconst getY0End = (boardSizeY, y, isBlack) => isBlack ? (boardSizeY - 1) - y : y;\nconst getY0EndCurried = R.curry(getY0End);\nconst printXAndYPosition = (p) => ` ${p.x},${p.y} |`;\nfunction printUnicodePosition(position) {\n    if (isBackGroundBlack(position.x, position.y)) {\n        if (hasWhitePiece(position))\n            return '\\u{25CF}';\n        else if (hasBlackPiece(position))\n            return '\\u{25CB}';\n        else\n            return ' ';\n    }\n    else {\n        if (hasWhitePiece(position))\n            return '\\u{25D9}';\n        else if (hasBlackPiece(position))\n            return '\\u{25D8}';\n        else\n            return '\\u{2588}';\n    }\n}\n/**\n * Checks if an array of positions contains a position.\n */\nconst containsXY = (positions, position) => positions ? positions.some(p => hasSameXY(p, position)) : false;\n/**\n * Checks if an array of positions NOT contains a position.\n */\nconst notContainsXY = R.compose(R.not, containsXY);\n/**\n * Get ordered positions IPosition[Y][positions]\n */\nconst getOrderedPositions = (getYAs, boardSizeY, isBlack, positions) => positions.reduce((ordered, position) => {\n    const y = getYAs(boardSizeY, position.y, isBlack);\n    ordered[y] = (ordered[y] || []).concat(position);\n    return ordered;\n}, []);\nconst getOrderedPositionsCurried = R.curry(getOrderedPositions);\n/**\n * Get ordered positions as black IPosition[Y = 0 -> endRow][positions]\n */\nconst getOrderedPositionsY0Start = getOrderedPositionsCurried(getY0Start);\n/**\n * Get ordered positions as black IPosition[Y = 0 -> endRow][positions]\n */\nconst getOrderedPositionsY0StartCurried = R.curry(getOrderedPositionsY0Start);\n/**\n * Get ordered positions as white IPosition[Y = endRow -> 0][positions]\n */\nconst getOrderedPositionsY0End = getOrderedPositionsCurried(getY0End);\n/**\n * Get ordered positions as white IPosition[Y = endRow -> 0][positions]\n */\nconst getOrderedPositionsY0EndCurried = R.curry(getOrderedPositionsY0End);\nexport { containsXY, isBackGroundBlack, getPositionFromArray, getPositionFromPositions, getPositionWhereCanIGoFromArray, getPositionsWhereCanIGoFromArray, getToSearchOrder, getOrderedPositions, getOrderedPositionsY0Start, getOrderedPositionsY0StartCurried, getOrderedPositionsY0End, getOrderedPositionsY0EndCurried, getOrderedPositionsCurried, getXAndY, getY0Start, getY0End, getY0EndCurried, hasSameXY, hasBlackPiece, hasPiece, hasNoPiece, hasWhitePiece, notContainsXY, printXAndYPosition, printUnicodePosition, setICanGoHere, setPiece, setPieceToBlack, setPieceToWhite };\n//# sourceMappingURL=Position.js.map"]}